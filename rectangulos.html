<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>4 piezas – EQUIPO 1 (Colaborativo)</title>
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<style>
  :root{
    --bg:#f7f8fb; --grid: rgba(0,0,0,.05);
    --piece:#cfecee; --stroke:#3a556a; --shadow: rgba(0,0,0,.08);
  }
  html,body{ height:100%; margin:0; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:var(--bg); }
  .board{
    position:absolute; inset:0; 
    background-image:
      linear-gradient(var(--grid) 1px, transparent 1px),
      linear-gradient(90deg, var(--grid) 1px, transparent 1px);
    background-size:40px 40px; background-position: -1px -1px;
  }
  .toolbar{
    position:fixed; top:10px; left:50%; transform:translateX(-50%);
    display:flex; gap:10px; align-items:center; background:#fff;
    border:1px solid #e6e6e6; border-radius:999px; box-shadow:0 8px 20px rgba(0,0,0,.06);
    padding:8px 16px; font-size:14px; z-index:10; user-select:none; flex-wrap: wrap;
    max-width: 90%;
  }
  .pill{ padding:6px 12px; border:1px solid #e6e6e6; border-radius:999px; background:#fff; cursor:pointer; font-size:13px; }
  .pill:hover{ background:#f5f5f5; }
  .badge{ font-weight:600; color:#666; font-size:13px; }
  .msg{ padding:8px 12px; border:1px solid #e6e6e6; background:#fff; border-radius:12px; box-shadow:0 6px 16px rgba(0,0,0,.05); font-size:13px; }
  .msg b{ font-weight:700; }
  .status{ display:inline-block; width:8px; height:8px; border-radius:50%; margin-right:6px; }
  .status.online{ background:#22c55e; }
  .status.offline{ background:#ef4444; }

  .piece{
    position:absolute; left:0; top:0;
    width:180px; height:120px;
    background:var(--piece);
    border:2px solid var(--stroke);
    border-radius:0;
    box-shadow: 0 10px 20px var(--shadow);
    cursor:grab; touch-action:none; user-select:none;
    transition: box-shadow 0.2s;
  }
  .piece:active{ cursor:grabbing; box-shadow: 0 15px 30px rgba(0,0,0,.15); }
  .handle-rotate{
    position:absolute; left:50%; transform:translateX(-50%);
    bottom:-24px; width:16px; height:16px; border:2px solid var(--stroke);
    border-radius:50%; background:#fff; box-shadow:0 2px 6px rgba(0,0,0,.1);
    cursor:grab; touch-action:none;
  }
  .label{
    position:fixed; left:16px; bottom:16px;
    background:#000; color:#fff; font-weight:700; padding:10px 14px;
    border-radius:12px; box-shadow:0 8px 20px rgba(0,0,0,.2); letter-spacing:.5px;
  }
  .room-id{
    position:fixed; right:16px; bottom:16px;
    background:#fff; color:#000; font-weight:600; padding:8px 12px;
    border-radius:8px; border:2px solid #000; font-size:12px; font-family: monospace;
  }
</style>
</head>
<body>
  <div class="toolbar">
    <button id="btnReset" class="pill">Reset ejercicio</button>
    <span class="msg">
      <span class="status online" id="statusDot"></span>
      <b>Modo colaborativo.</b> Todos pueden mover y rotar las piezas en tiempo real.
    </span>
    <span class="badge">Sala: EQUIPO1 · <span id="userCount">1</span> conectados</span>
  </div>
  <div id="board" class="board"></div>
  <div class="label">EQUIPO 1</div>
  <div class="room-id">Sala: <span id="roomDisplay">EQUIPO1</span></div>

<script>
(function(){
  const ROOM = 'EQUIPO1';
  const board = document.getElementById('board');
  const statusDot = document.getElementById('statusDot');
  const userCount = document.getElementById('userCount');

  const initialState = [
    { left: 120, top: 340, angle: 0 },
    { left: 340, top: 340, angle: 0 },
    { left: 560, top: 340, angle: 0 },
    { left: 780, top: 340, angle: 0 },
  ];

  let state = JSON.parse(localStorage.getItem('pieces_' + ROOM)) || [...initialState];
  const pieces = [];
  let isUpdatingFromPeer = false;
  
  const peer = new Peer('rectangulos-' + ROOM + '-' + Math.random().toString(36).substr(2, 6));
  const connections = new Set();

  peer.on('open', (id) => {
    console.log('Mi ID:', id);
    statusDot.className = 'status online';
    
    peer.on('connection', (conn) => {
      setupConnection(conn);
    });

    connectToRoom();
  });

  function connectToRoom() {
    const baseId = 'rectangulos-' + ROOM;
    for(let i = 0; i < 10; i++) {
      const targetId = baseId + '-' + i.toString(36);
      if(targetId !== peer.id) {
        try {
          const conn = peer.connect(targetId);
          setupConnection(conn);
        } catch(e) {}
      }
    }
  }

  function setupConnection(conn) {
    connections.add(conn);
    
    conn.on('open', () => {
      console.log('Conectado a:', conn.peer);
      userCount.textContent = connections.size + 1;
      conn.send({ type: 'state', state });
    });

    conn.on('data', (data) => {
      if(data.type === 'state') {
        isUpdatingFromPeer = true;
        state = data.state;
        updatePiecesFromState();
        setTimeout(() => { isUpdatingFromPeer = false; }, 100);
      } else if(data.type === 'update') {
        isUpdatingFromPeer = true;
        state[data.index] = data.piece;
        updatePieceFromState(data.index);
        setTimeout(() => { isUpdatingFromPeer = false; }, 100);
      } else if(data.type === 'reset') {
        isUpdatingFromPeer = true;
        state = [...initialState];
        updatePiecesFromState();
        setTimeout(() => { isUpdatingFromPeer = false; }, 100);
      }
    });

    conn.on('close', () => {
      connections.delete(conn);
      userCount.textContent = connections.size + 1;
    });
  }

  function broadcast(data) {
    connections.forEach(conn => {
      if(conn.open) {
        conn.send(data);
      }
    });
  }

  function setRotation(el, deg){
    el.style.transform = `rotate(${deg}deg)`;
  }

  function createPiece(i){
    const p = document.createElement('div');
    p.className = 'piece';
    p.dataset.index = i;
    p.dataset.angle = state[i].angle || 0;
    p.style.left = state[i].left + 'px';
    p.style.top  = state[i].top + 'px';
    setRotation(p, +p.dataset.angle);

    const h = document.createElement('div');
    h.className = 'handle-rotate';
    p.appendChild(h);

    board.appendChild(p);

    let dragging = false;
    let startX = 0, startY = 0, startLeft = 0, startTop = 0;

    p.addEventListener('pointerdown', (ev) => {
      if (ev.target === h) return;
      dragging = true;
      p.setPointerCapture(ev.pointerId);
      startX = ev.clientX; startY = ev.clientY;
      startLeft = parseFloat(p.style.left); startTop = parseFloat(p.style.top);
    });

    p.addEventListener('pointermove', (ev) => {
      if (!dragging) return;
      const dx = ev.clientX - startX;
      const dy = ev.clientY - startY;
      p.style.left = (startLeft + dx) + 'px';
      p.style.top  = (startTop + dy) + 'px';
    });

    p.addEventListener('pointerup', () => {
      if (dragging) {
        dragging = false;
        syncPiece(i, p);
      }
    });
    
    p.addEventListener('pointercancel', () => { dragging = false; });

    let rotating = false;
    let baseAngle = 0;
    let startAngle = 0;

    const angleFromPointer = (ev) => {
      const rect = p.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top + rect.height/2;
      const ang = Math.atan2(ev.clientY - cy, ev.clientX - cx) * 180/Math.PI;
      return ang;
    };

    h.addEventListener('pointerdown', (ev) => {
      ev.stopPropagation();
      rotating = true;
      h.setPointerCapture(ev.pointerId);
      baseAngle = +p.dataset.angle;
      startAngle = angleFromPointer(ev);
    });

    h.addEventListener('pointermove', (ev) => {
      if(!rotating) return;
      const current = angleFromPointer(ev);
      const diff = current - startAngle;
      const newAng = baseAngle + diff;
      p.dataset.angle = newAng;
      setRotation(p, newAng);
    });

    h.addEventListener('pointerup', () => {
      if (rotating) {
        rotating = false;
        syncPiece(i, p);
      }
    });
    
    h.addEventListener('pointercancel', () => { rotating = false; });

    pieces.push(p);
  }

  function syncPiece(index, pieceEl) {
    if (isUpdatingFromPeer) return;
    
    const pieceData = {
      left: parseFloat(pieceEl.style.left),
      top: parseFloat(pieceEl.style.top),
      angle: parseFloat(pieceEl.dataset.angle)
    };
    
    state[index] = pieceData;
    localStorage.setItem('pieces_' + ROOM, JSON.stringify(state));
    broadcast({ type: 'update', index, piece: pieceData });
  }

  function updatePieceFromState(i) {
    if(pieces[i]) {
      pieces[i].style.left = state[i].left + 'px';
      pieces[i].style.top = state[i].top + 'px';
      pieces[i].dataset.angle = state[i].angle || 0;
      setRotation(pieces[i], +pieces[i].dataset.angle);
    }
  }

  function updatePiecesFromState() {
    pieces.forEach((p, i) => {
      if (state[i]) {
        p.style.left = state[i].left + 'px';
        p.style.top = state[i].top + 'px';
        p.dataset.angle = state[i].angle || 0;
        setRotation(p, +p.dataset.angle);
      }
    });
    localStorage.setItem('pieces_' + ROOM, JSON.stringify(state));
  }

  for(let i=0; i<4; i++) {
    createPiece(i);
  }

  document.getElementById('btnReset').addEventListener('click', () => {
    state = [...initialState];
    updatePiecesFromState();
    broadcast({ type: 'reset' });
  });

  setInterval(() => {
    userCount.textContent = connections.size + 1;
  }, 2000);
})();
</script>
</body>
</html>
